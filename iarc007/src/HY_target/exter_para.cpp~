#include <ros/ros.h>

#include <stdio.h>
#include <stdlib.h>

#include <opencv/cv.h>
#include <opencv/highgui.h>


int n_boards;
const int board_dt = 10;
/* Num of corners along the x-y direction of chessboard */
int board_w;
int board_h;


void help()
{
	printf("Calibration from disk. Call convention:\n\n"
		"Where: board_{w,h} are the # of internal corners in the checkerboard\n"
		"       width (board_w) and height (board_h)\n"
		"       image_list is space separated list of path/filename of checkerboard\n"
		"       images\n\n"
		"Hit "ESC" to complete calibration and quit the program.\n");
}

int main(int argc,char** argv)
{
	ros::init(argc,argv,"exter_param");
	ros::NodeHandle nh;
	
	CvCapture* capture= cvCreateCameraCapture(0);
	assert(capture);

	help();
	board_w = 11;
	board_h = 8;
	/* Num of the all corners of chessboard */
	int board_n  = board_w * board_h;
	CvSize board_sz = cvSize( board_w, board_h );

	char names[2048];

	n_boards=1;

	cvNamedWindow( "Calibration" );

	/* ALLOCATE STORAGE of corners */
	CvMat* image_points      = cvCreateMat(board_n,2,CV_32FC1);
	CvMat* object_points     = cvCreateMat(board_n,3,CV_32FC1);
	/* Param of camera */
	CvMat *intrinsic = (CvMat*)cvLoad("catkin_ws/src/iarc007/doc/Intrinsics.xml");
	CvMat *distortion = (CvMat*)cvLoad("catkin_ws/src/iarc007/doc/Distortion.xml");

	CvMat* rotation_vector=cvCreateMat(3,1,CV_32FC1);
	CvMat* translation_vector=cvCreateMat(3,1,CV_32FC1);
	CvMat* rotation_mat=cvCreateMat(3,3,CV_32FC1);
	CvMat* jacobian=cvCreateMat(3,1,CV_32FC1);

	IplImage* image = cvQueryFrame(capture);;
	IplImage* gray_image = 0;
	CvPoint2D32f* corners = new CvPoint2D32f[ board_n ];
	int corner_count;

	while(image)
	{
		//We'll need this for subpixel accurate stuff
		if(gray_image == 0  && image){
			gray_image = cvCreateImage(cvGetSize(image),8,1);
		}
		if(!image){
			printf("null image\n");
		}

		int found = cvFindChessboardCorners(image,board_sz,corners,&corner_count,CV_CALIB_CB_ADAPTIVE_THRESH | CV_CALIB_CB_FILTER_QUADS);

		//Get Subpixel accuracy on those corners
		cvCvtColor(image, gray_image, CV_RGB2GRAY);
		cvFindCornerSubPix(gray_image, corners, corner_count,cvSize(11,11),cvSize(-1,-1), cvTermCriteria( CV_TERMCRIT_EPS+CV_TERMCRIT_ITER, 30, 0.1 ));
		//Draw it
		cvDrawChessboardCorners(image, board_sz, corners, corner_count, found);
		cvShowImage( "Calibration", image );
		
		if( corner_count == board_n ){
			printf("Found = %d for %s\n",found,names);
		}
		for( int i=0; i<board_n; ++i )
		{
			CV_MAT_ELEM(*image_points, float,i,0) = corners[i].x;
			CV_MAT_ELEM(*image_points, float,i,1) = corners[i].y;
			CV_MAT_ELEM(*object_points,float,i,0) = (float)(i/board_w);
			CV_MAT_ELEM(*object_points,float,i,1) = (float)(i%board_w);
			CV_MAT_ELEM(*object_points,float,i,2) = 0.0f;
		}

		cvFindExtrinsicCameraParams2(object_points,image_points,intrinsic,distortion,rotation_vector,translation_vector );

		cvRodrigues2(rotation_vector,rotation_mat,jacobian=NULL);

		char c=cvWaitKey(0);

		if(c==27){
			cvSave("rotation_vector",rotation_vector);
			cvSave("Rotation.xml",rotation_mat);
			cvSave("Translation.xml",translation_vector);
			break;
		}

		image = cvQueryFrame(capture);
	}

	return 0;
}
