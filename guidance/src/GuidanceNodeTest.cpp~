#include "pub.h"
int grey( Mat src )
{
//  Mat  dst;
 int histSize = 255;
 float range[] = { 0, 255 } ;
 const float* histRange = { range };

 bool uniform = true; bool accumulate = false;
 
 Mat g_hist; 

 calcHist( &src, 1, 0, Mat(), g_hist, 1, &histSize, &histRange, uniform, accumulate );
 int hist_w = 255; int hist_h = 255;
 int bin_w = cvRound( (double) hist_w/histSize );
 int dis_count_max = 0;
 int true_count = 0;
 Mat histImage( hist_w, hist_h, CV_8UC3, Scalar( 0,0,0) );
 IplImage ipl_histImage(histImage);
 for( int i = 5; i < histSize; i++ )
   {
	 //printf("g_hist.at<float>(%d) is %f\n",i-1,g_hist.at<float>(i-1));
       cvLine( &ipl_histImage, cvPoint( bin_w*(i-1), hist_h - cvRound(g_hist.at<float>(i-1)) ) ,cvPoint( bin_w*(i), hist_h - cvRound(g_hist.at<float>(i)) ),cvScalar( 0, 255, 0), 2, 8, 0  );
       if(cvRound(g_hist.at<float>(i-1))>true_count&&(cvRound(g_hist.at<float>(i-1))>15))
       {
    	   if(true_count!=0)
    	   {
    		   if(cvRound(g_hist.at<float>(i-1))-true_count>=30)
    		   {
    	    	   dis_count_max =bin_w*(i);
    	             true_count = cvRound(g_hist.at<float>(i-1));
    		   }
    	   }
    	   else
    	   {
    		   dis_count_max =bin_w*(i);
    		   true_count = cvRound(g_hist.at<float>(i-1));
    	   }
       }
    }
 if(true_count == 0 )
 {
	 printf("cannot detect clearly!!!");
 }
// imshow("calcHist ",histImage );
//printf("dis_count_max is %d\n",dis_count_max);
//printf("true_count is %d\n",true_count);

return dis_count_max;
}

bool calibration(cv::Mat  color_image, CvMat* intrinsic_yqt,int num_guidance)
{
	cout<<color_image.rows<<"::"<<color_image.cols<<endl;
	cout<<intrinsic_yqt<<endl;
    CvCapture* capture;// = cvCreateCameraCapture( 0 );
    bool right_one=false;
    int n_boards = 0;
    const int board_dt = 10;
    int  board_w = 5;//atoi(argv[1]);
      int board_h = 4;//atoi(argv[2]);
      int board_n  = board_w * board_h;
      CvSize board_sz = cvSize( board_w, board_h );

    cvNamedWindow( "Calibration" ,0);
    //ALLOCATE STORAGE
    CvMat* image_points      = cvCreateMat(board_n,2,CV_32FC1);
    CvMat* object_points     = cvCreateMat(board_n,3,CV_32FC1);

   float distortion_[5]={0,0,0,0,0};

   CvMat *distortion=cvCreateMat(5,1,CV_32FC1);


    cvmSet(distortion,0,0, distortion_[0]);
    cvmSet(distortion,1,0, distortion_[1]);
    cvmSet(distortion,2,0, distortion_[2]);
    cvmSet(distortion,3,0, distortion_[3]);
    cvmSet(distortion,4,0, distortion_[4]);
    float front_chess_R_body_yqt_[9] = {0,0,-1,
                                 0,-1,0,
                                 -1,0,0};
    float right_chess_R_body_yqt_[9]={0,0,-1,
                                  1,0,0,
                                  0,-1,0};
    float back_chess_R_body_yqt_[9]={0,0,-1,
                                  0,1,0,
                                  1,0,0};
    float left_chess_R_body_yqt_[9]={0,0,-1,
                                  -1,0,0,
                                  0,-1,0};
    CvMat *front_chess_R_body_yqt =cvCreateMat(3,3,CV_32FC1);
      CvMat *right_chess_R_body_yqt =cvCreateMat(3,3,CV_32FC1);
        CvMat *back_chess_R_body_yqt =cvCreateMat(3,3,CV_32FC1);
          CvMat *left_chess_R_body_yqt =cvCreateMat(3,3,CV_32FC1);
          CvMat *front_body_R_chess_yqt =cvCreateMat(3,3,CV_32FC1);
            CvMat *right_body_R_chess_yqt =cvCreateMat(3,3,CV_32FC1);
              CvMat *back_body_R_chess_yqt=cvCreateMat(3,3,CV_32FC1);
                CvMat *left_body_R_chess_yqt =cvCreateMat(3,3,CV_32FC1);
    for(int ii=0;ii<3;++ii)
    {
        for (int jj=0;jj<3;++jj)
        {
             cvmSet(front_chess_R_body_yqt,ii,jj, front_chess_R_body_yqt_[ii*3+jj]);
             cvmSet(right_chess_R_body_yqt,ii,jj, right_chess_R_body_yqt_[ii*3+jj]);
             cvmSet(back_chess_R_body_yqt,ii,jj, back_chess_R_body_yqt_[ii*3+jj]);
             cvmSet(left_chess_R_body_yqt,ii,jj, left_chess_R_body_yqt_[ii*3+jj]);
        }
    }




    CvMat* rotation_vector=cvCreateMat(3,1,CV_32FC1);
    CvMat* translation_vector=cvCreateMat(3,1,CV_32FC1);
    CvMat* rotation_mat=cvCreateMat(3,3,CV_32FC1);
    CvMat* jacobian=cvCreateMat(3,1,CV_32FC1);



    IplImage* image = cvCreateImage(cvSize(320,240),8,1);// = cvQueryFrame( capture );
//    IplImage* image=0;
    IplImage* gray_image = 0; //for subpixel
    CvPoint2D32f* corners = new CvPoint2D32f[ board_n ];
    int corner_count;
    //cvConvert(color_image,image);
    for(int dy=0; dy<color_image.rows; ++dy)
    {
        for(int dx=0; dx<color_image.cols; ++dx)
        {
            ((uchar*) (image->imageData+dy*image->widthStep))[dx]=color_image.at<uchar>(dy,dx);
          }
    }

           if(gray_image == 0  && image) //We'll need this for subpixel accurate stuff
            gray_image = cvCreateImage(cvGetSize(image),8,1);
  //    cvShow("Calibration",image);

        if(!image)
            printf("null image\n");

        int found = cvFindChessboardCorners(
          image,
          board_sz,
          corners,
          &corner_count,
          CV_CALIB_CB_ADAPTIVE_THRESH | CV_CALIB_CB_FILTER_QUADS
                );


        cvCopy(image,gray_image);
        cvFindCornerSubPix(gray_image, corners, corner_count,
                cvSize(11,11),cvSize(-1,-1), cvTermCriteria( CV_TERMCRIT_EPS+CV_TERMCRIT_ITER, 30, 0.1 ));

        cvDrawChessboardCorners(image, board_sz, corners, corner_count, found);
        cvShowImage( "Calibration", image );

         if( corner_count == board_n ){}
          for( int i=0; i<board_n; ++i)
            {
             CV_MAT_ELEM(*image_points, float,i,0) = corners[i].x;
             CV_MAT_ELEM(*image_points, float,i,1) = corners[i].y;
             CV_MAT_ELEM(*object_points,float,i,0) = i/board_w;
             CV_MAT_ELEM(*object_points,float,i,1) = i%board_w;
             CV_MAT_ELEM(*object_points,float,i,2) = 0.0f;
            }

          cvFindExtrinsicCameraParams2(
                              object_points,image_points,intrinsic_yqt,distortion,rotation_vector,translation_vector
                              );//
          cvRodrigues2(
            rotation_vector,rotation_mat,jacobian=NULL
                       );
           char c=cvWaitKey(0);
          printf("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb");
          //cout<<c<<endl;
          cvTranspose(rotation_mat,rotation_mat);
         if(c==' ')
         {

             if (num_guidance==0)
             {
        cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr0.xml",rotation_mat);
             }
             else if (num_guidance==1)
             {
               cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr1.xml",rotation_mat);
             }
             else if (num_guidance==2)
             {
               cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr2.xml",rotation_mat);
             }
             else if (num_guidance==3)
             {
               cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr3.xml",rotation_mat);
               //cvSave("Rotationr3.xml",rotation_mat);
             }
             else if (num_guidance==4)
             {
                 //printf("zhangyuyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy");

            	 cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr4.xml",rotation_mat);
             }
              cvTranspose(front_chess_R_body_yqt,front_body_R_chess_yqt);
               cvTranspose(right_chess_R_body_yqt,right_body_R_chess_yqt);
                cvTranspose(back_chess_R_body_yqt,back_body_R_chess_yqt);
                 cvTranspose(left_chess_R_body_yqt,left_body_R_chess_yqt);

             cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/front_body_R_chess.xml",front_body_R_chess_yqt);
             cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/right_body_R_chess.xml",right_body_R_chess_yqt);
             cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/back_body_R_chess.xml",back_body_R_chess_yqt);
             cvSave("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/left_body_R_chess.xml",left_body_R_chess_yqt);

             right_one=true;

         }
         cvReleaseMat(&front_chess_R_body_yqt);
          cvReleaseMat(&right_chess_R_body_yqt);
           cvReleaseMat(&back_chess_R_body_yqt);
            cvReleaseMat(&left_chess_R_body_yqt);
            cvReleaseMat(&front_body_R_chess_yqt);
             cvReleaseMat(&right_body_R_chess_yqt);
              cvReleaseMat(&back_body_R_chess_yqt);
               cvReleaseMat(&left_body_R_chess_yqt);
         cvReleaseMat(&image_points);
          cvReleaseMat(&object_points);
    //       cvReleaseMat(&intrinsic_yqt);
            cvReleaseMat(&distortion);
             cvReleaseMat(&rotation_vector);
             cvReleaseMat(&translation_vector);
             cvReleaseMat(&rotation_mat);
             cvReleaseMat(&jacobian);
             delete [] corners;
        	  cvReleaseImage(&image);
        	cvReleaseImage(&gray_image);
         return right_one;
}

CvMat* att;

static int getContoursByC(Mat src1, double minarea, double whRatio , int d)
{
	for(int j_b=0;j_b<240;j_b++)
    {
    	for (int i_b=0;i_b<320;i_b++)
    	{
    			 	 	float ddd_b =float( src1.at<uchar>(j_b,i_b))*2/100;
			 	 	 	float yyy_b = (j_b - camera_cv) * ddd_b / focal;

						if(yyy_b >= (height_zy-0.09)-0.10)
    			 	        		{
									src1.at<uchar>(j_b,i_b) = 0;
    			 	        		}
						if(ddd_b >= 2.0)
    			 	        		{
									src1.at<uchar>(j_b,i_b) = 0;
    			 	        		}
    	}
    }
	IplImage src2(src1);
	src_contours=&src2;
    if (!src_contours)
    {
        printf("read data error!\n");
        return -1;
    }

    cv::Mat raw_dist( src1.size(), CV_8UC1 );
    //cv::Mat deal_dst( src1.size(), CV_8UC1 );

    //Mat dst= Mat::zeros(sizeof(src1), CV_8UC3);
    //the parm. for cvFindContours
   // CvMemStorage* storage = cvCreateMemStorage(0);
    CvSeq* contour = 0;

    double maxarea = 0;

    //for display
   // cvNamedWindow("Source", CV_WINDOW_NORMAL);
   // cvShowImage("Source", src);


//    cvNamedWindow("过滤", 3);
//    cvShowImage("过滤", src);
    //二值化
    //二值化
    cvThreshold(src_contours, src_contours, 30, 255, CV_THRESH_BINARY);
//    Dilation(src, 3);
//    Erosion(src,3);
    Erosion(src_contours,1);
    Dilation(src_contours, 1);
    Dilation(src_contours,3);
    Erosion(src_contours,3);
    Dilation(src_contours,5);
    Erosion(src_contours,5);


        //cvNamedWindow("二值化", 3);
       //cvShowImage("二值化", src);
    //提 取轮廓
    cvFindContours(src_contours, storage, &contour, sizeof(CvContour), CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);
   cvZero(dst_contours);//清空数组
   raw_dist = Mat::zeros(src1.size(),  CV_8UC1);
   //deal_dst= Mat::zeros(src1.size(),  CV_8UC1);

   CvSeq* _contour = contour;
   CvSeq* max_contour = 0;
    /*CvSeq* _contour为了保存轮廓的首指针位置，因为随后contour将用来迭代*/



    int maxAreaIdx = -1, iteratorIdx = 0;//n为面积最大轮廓索引，m为迭代索引
    for (int iteratorIdx = 0; contour != 0; contour = contour->h_next, iteratorIdx++/*更新迭代索引*/)
    {

        double tmparea = fabs(cvContourArea(contour));
       // printf("area is %f\n",tmparea);
        if (tmparea > maxarea)
        {
            maxarea = tmparea;
            maxAreaIdx = iteratorIdx;
            continue;
        }
        if (tmparea < minarea)
        {
            //删除面积小于设定值的轮廓
            cvSeqRemove(contour, 0);
            continue;
        }
        CvRect aRect = cvBoundingRect(contour, 0);
                if ((aRect.width / aRect.height)<whRatio)
                {
                    //删除宽高比例小于设定值的轮廓
                    cvSeqRemove(contour, 0);
                    continue;
                }
    }

    contour = _contour;
    int count = 0;
    int valid_count = -1;
    //printf("valid_count = -1!\n");
    float point_x;
    float point_y;
    float point_z;
    float  camera_point_image[3];
    float depth_point_image[3];
    if(d == 1)
    {
    	chess_R_ca = (CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr1.xml");
    	body_R_chess=(CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/right_body_R_chess.xml");
    }
    if(d == 2)
    {
    	chess_R_ca = (CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr2.xml");
    	body_R_chess=(CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/back_body_R_chess.xml");
    }
    if(d == 3)
    {
    	chess_R_ca = (CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr3.xml");
    	body_R_chess=(CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/back_body_R_chess.xml");
    }
    if(d == 4)
    {
    	chess_R_ca = (CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr4.xml");
    	body_R_chess=(CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/left_body_R_chess.xml");
    }
 //cvTranspose(body_R_chess,body_R_chess);
	//cvTranspose(chess_R_ca,chess_R_ca);
	Quaternion_To_Euler(q_guidance, att);

	float roll,pitch,yaw;

	roll = cvmGet(att,0,0);
	pitch = cvmGet(att,1,0);
	yaw = cvmGet(att,2,0);

	/*	R_g_b coming from aerial pilot indicates transformation from ground to body (All observe left-multiply principle)	*/
	Euler_To_Matrix(roll,pitch,yaw,earth_R_body);
//	cvmSet(earth_R_body,0,0,0);
//	cvmSet(earth_R_body,0,1,1);
//	cvmSet(earth_R_body,0,2,0);
//	cvmSet(earth_R_body,1,0,-1);
//	cvmSet(earth_R_body,1,1,0);
//	cvmSet(earth_R_body,1,2,0);
//	cvmSet(earth_R_body,2,0,0);
//	cvmSet(earth_R_body,2,1,0);
//	cvmSet(earth_R_body,2,2,1);

    		cvGEMM(saidong_R_earth,earth_R_body,1,NULL,0,saidong_R_body);
            cvGEMM(saidong_R_body,body_R_chess,1,NULL,0,saidong_R_chess);
           	cvGEMM(saidong_R_chess,chess_R_ca,1,NULL,0,saidong_R_ca);
//           printf("\n%f	%f	%f \n %f	%f	%f \n%f	%f	%f\n",cvmGet(saidong_R_body,0,0),cvmGet(saidong_R_body,0,1),cvmGet(saidong_R_body,0,2),cvmGet(saidong_R_body,1,0),cvmGet(saidong_R_body,1,1),cvmGet(saidong_R_body,1,2),cvmGet(saidong_R_body,2,0),cvmGet(saidong_R_body,2,1),cvmGet(saidong_R_body,2,2));
//			cout << "---saidong_R_ca---" << endl;
//			for(int i = 0;i < 9;i++){
//				cout << saidong_R_ca->data.fl[i] << ' ';
//				if(!((i+1)%3))
//					cout << endl;
//			}
        for (; contour != 0; contour = contour->h_next)
        {
        	//raw_dist = Mat::zeros(src1.size(),  CV_8UC1);
            int point_sum_x = 0;
            int point_sum_y = 0;
            int point_average_x = 0;
            float point_average_z = 0;
            int point_average_y = 0;
            int point_count = 0;
        	count++;
            double tmparea = fabs(cvContourArea(contour));
            //if (tmparea == maxarea /*k==n*/)
            if (tmparea > 1500)
            {
            	///printf("start counting....");
                CvScalar color = CV_RGB(255, 255, 255);
                cvDrawContours(dst_contours, contour, color, color, -1, CV_FILLED, 8);
               // max_contour = contour;
                for(int j=0;j<dst_contours->height;j++)
                {
                	for (int i=0;i<dst_contours->width;i++)
                	{
                		 if(cvPointPolygonTest( contour,cvPoint2D32f(i,j), 0 )>0)
                		                  {
                			 	 	 	 	 float ddd =float( src_src.at<uchar>(j,i))*2/100;
                			 	 	 	 	 if(ddd>0.3&&ddd<2.5)
                			 	 	 	 	 {
                			 	 	 	 		 point_z =  ddd;
                 			 	 	 	 	    point_x = (i - camera_cu) * point_z / focal;
                			 	 	 	 	     point_y = (j - camera_cv) * point_z / focal;
                			 	 	 	 	     point_sum_x = point_sum_x + i;
                			 	 	 	 	     point_sum_y = point_sum_y + j;
                			 	 	 	     	 point_count = point_count + 1;
                			 	 	 	  	    //printf("point_y is %d\n", point_sum_x);
                			 	 	 	     	raw_dist.at<uchar>(j,i) = 	src_src.at<uchar>(j,i);
                			 	 	 	 	     camera_point_image[0] = point_x;
                			 	 	 	 	     camera_point_image[1] =point_y;
                			 	 	 	 	     camera_point_image[2] = point_z;
//                			 	 	 	 	    if(point_y>height_zy-0.2)
//                			 	 	 	 	    {
//                			 	 	 	 	    	raw_dist.at<uchar>(j,i) = 0;
//                			 	 	 	 	    }
                			 	          		transform_point_to_real(depth_point_image, saidong_R_ca, camera_point_image);
                			 	          		//if(depth_point_image[2] >= height_zy-0.2)//去除地面点
									if(depth_point_image[2] >= -0.2+(height_zy-0.09))
                			 	        		{
                			 	        			raw_dist.at<uchar>(j,i) = 0;
                   			 	 	 	     	    point_count = point_count - 1;
                   			 	 	 	     	    point_sum_x = point_sum_x - i;
                   			 	 	 	     	    point_sum_y = point_sum_y - j;
                			 	        		}
                			 	 	 	 	 }

            			 	 	 	 	    //imshow("bufen分开2", raw_dist);
                		                  }
                	}
                }
                ram_point_count = point_count;
                if(point_count>=300)
                {
                	valid_count++;
                	//printf("point_count is %d\n", point_count);
                	point_average_z = float(grey(raw_dist))*2/100;
                	 point_average_x = cvRound(point_sum_x / point_count);
                	 point_average_y = cvRound(point_sum_y / point_count);
                	 cv::circle(raw_dist, Point(point_average_x,point_average_y), 5, Scalar(255,0,0),  -1, 8, 0);
                    //printf("point_average_x is %d***point_average_y is %d\n", point_average_x,point_average_y);
                	 point_x = (point_average_x - camera_cu) * point_average_z / focal;
                	 pub_point_x = point_x;
                	 pub_point_y =  (point_average_y - camera_cv) * point_average_z / focal;
                	 pub_point_z = point_average_z;
                   //printf("point_x is %f***point_y is %f***point_z is %f***valid_count is %d\n", pub_point_x,pub_point_y,pub_point_z,valid_count);
                	 if(valid_count==0)
                	 {
                		 if(sqrt(pub_point_x*pub_point_x+pub_point_z*pub_point_z)<2.0)
                		 {
                			 if((ram_obstacle_delect_x!=0)||(ram_obstacle_delect_y!=0)||(ram_obstacle_delect_z!=0))
                			 {
                    			 ram_obstacle_delect_x = pub_point_x;
                    			 ram_obstacle_delect_y = pub_point_y;
                    			 ram_obstacle_delect_z = pub_point_z;
                    			 obstacle_delect_x[valid_count+stat_obstacle_count] = pub_point_x;
                    			 obstacle_delect_y[valid_count+stat_obstacle_count] = pub_point_y;
                    			 obstacle_delect_z[valid_count+stat_obstacle_count] = pub_point_z;
                    			 pub_obstacle_count = pub_obstacle_count+1;
                			 }
                			 else
                			 {
                    			 ram_obstacle_delect_x = pub_point_x;
                    			 ram_obstacle_delect_y = pub_point_y;
                    			 ram_obstacle_delect_z = pub_point_z;
                			 }

                			// printf("++++++++1\n");
                			 //printf("valid_count is %d\n",valid_count);
                			  	//printf("point_y is %f\n", pub_point_z);
                			// printf("*********%f***********\n",atan2(obstacle_delect_x[valid_count],obstacle_delect_y[valid_count])*180/PAI );
                			// printf("area is %f*******obstacle(%d)\n",tmparea,valid_count+1);
                		 }
                		 else
                		 {

                			 valid_count=valid_count-1;
                            // printf("valid_count -1!\n");
                		 }
                	 }
                	 if(valid_count>0)
                	 {
                		 if(abs(atan2(pub_point_z,pub_point_x)*180/PAI-atan2(obstacle_delect_z[valid_count-1],obstacle_delect_x[valid_count-1])*180/PAI)>5)
                		 {
                			 if(sqrt(pub_point_x*pub_point_x+pub_point_z*pub_point_z)<2.0)
                			 {
                    			 if((ram_obstacle_delect_x!=0)||(ram_obstacle_delect_y!=0)||(ram_obstacle_delect_z!=0))
                    			 {
                        			 ram_obstacle_delect_x = pub_point_x;
                        			 ram_obstacle_delect_y = pub_point_y;
                        			 ram_obstacle_delect_z = pub_point_z;
                        			 obstacle_delect_x[valid_count+stat_obstacle_count] = pub_point_x;
                        			 obstacle_delect_y[valid_count+stat_obstacle_count] = pub_point_y;
                        			 obstacle_delect_z[valid_count+stat_obstacle_count] = pub_point_z;
                        			 pub_obstacle_count = pub_obstacle_count+1;
                    			 }
                    			 else
                    			 {
                        			 ram_obstacle_delect_x = pub_point_x;
                        			 ram_obstacle_delect_y = pub_point_y;
                        			 ram_obstacle_delect_z = pub_point_z;
                    			 }
                    			// printf("++++++++2\n");
                    			 //printf("valid_count is %d\n",valid_count);
                				// printf("%f***********************%f\n",atan2(obstacle_delect_x[valid_count],obstacle_delect_y[valid_count])*180/PAI , atan2(obstacle_delect_x[valid_count-1],obstacle_delect_y[valid_count-1])*180/PAI);
                			//	 printf("area is %f*******obstacle(%d)\n",tmparea,valid_count+1);
                			 }
                			 else
                			 {
                    			 valid_count=valid_count-1;
                                // printf("valid_count -1!\n");
                			 }
                		  }
                		 else
                		 {
                			 if(sqrt(pub_point_x*pub_point_x+pub_point_z*pub_point_z)<2.0)
                			 {
                				 valid_count=valid_count-1;
                    			 if((ram_obstacle_delect_x!=0)||(ram_obstacle_delect_y!=0)||(ram_obstacle_delect_z!=0))
                    			 {
                        			 ram_obstacle_delect_x = pub_point_x;
                        			 ram_obstacle_delect_y = pub_point_y;
                        			 ram_obstacle_delect_z = pub_point_z;
                        			 obstacle_delect_x[valid_count+stat_obstacle_count] = pub_point_x;
                        			 obstacle_delect_y[valid_count+stat_obstacle_count] = pub_point_y;
                        			 obstacle_delect_z[valid_count+stat_obstacle_count] = pub_point_z;
                    			 }
                    			 else
                    			 {
                        			 ram_obstacle_delect_x = pub_point_x;
                        			 ram_obstacle_delect_y = pub_point_y;
                        			 ram_obstacle_delect_z = pub_point_z;
                    			 }
                			 }
                			 else
                			 {
                    			 valid_count=valid_count-1;
                                 //printf("valid_count -1!\n");
                			 }
                		 }
                	 }
                     printf("valid_count = %d\n",valid_count);
                     printf("pub_obstacle_count = %d\n",pub_obstacle_count);
                }

//                else
//                {
//                	obstacle_delect_x[valid_count] = 1;
//                	obstacle_delect_y[valid_count] = 1;
//                	obstacle_delect_z[valid_count] = 1;
//                	//cvWaitKey(0);
//                }
          	    // printf("pub_obstacle_count is %d\n", pub_obstacle_count);
            }
            /*k++;*/
        }
        //printf("The total number of contours is:%d", count);
    if(d == 0)
    {
    	     imshow("分开0", raw_dist);
    }
    if(d == 1)
    {
    	    cvShowImage("轮廓1", dst_contours);
    	   // namedWindow("分开1");
    	     imshow("分开1", raw_dist);
    }
    if(d == 2)
    {
    	    cvShowImage("轮廓2", dst_contours);
    	   // namedWindow("分开2");
    	     imshow("分开2", raw_dist);
    }
    if(d == 3)
    {

    	    cvShowImage("轮廓3", dst_contours);
    	   // namedWindow("分开3");
    	     imshow("分开3", raw_dist);

    }
    if(d == 4)
    {
    	    cvShowImage("轮廓4", dst_contours);
    	  //  namedWindow("分开4");
    	     imshow("分开4", raw_dist);
    }
if(ram_point_count >= 300)
{
    for(int iii = stat_obstacle_count ; iii < valid_count+stat_obstacle_count+1;iii++)
    {

    	camera_point_real_word[0] = obstacle_delect_x[iii];
        camera_point_real_word[1] = obstacle_delect_y[iii];
        camera_point_real_word[2] = obstacle_delect_z[iii];
        //printf("carema*********************%f,%f,%f********************\n",camera_point_real_word[0], camera_point_real_word[1],camera_point_real_word[2]);
          		transform_point_to_real(depth_point_real_word, saidong_R_ca, camera_point_real_word);
        		pub_obstacle_yqt_x[iii] = depth_point_real_word[0];
        		pub_obstacle_yqt_y[iii] = depth_point_real_word[1];
        		//printf("stat_obstacle_count is %d\n",stat_obstacle_count);
        		printf("obstacle[%d] in camera[%d] in camera frame is(%f,%f,%f)\n",iii+1,d,camera_point_real_word[0],camera_point_real_word[1],  camera_point_real_word[2]);
        		printf("the distance of obstacle[%d] in camera[%d] in camera frame is [%f]\n",iii+1,d,sqrt(camera_point_real_word[0]*camera_point_real_word[0]+camera_point_real_word[2]*camera_point_real_word[2]));
        		printf("obstacle[%d] in camera[%d] in saidong frame is(%f,%f,%f)\n",iii+1,d,depth_point_real_word[0],depth_point_real_word[1],  depth_point_real_word[2]);
        		printf("-+-+-+-\n");
        }
}
    stat_obstacle_count = pub_obstacle_count;
//	  cvReleaseImage(&src);
//	cvReleaseImage(&dst);
}

static int getContoursByC_under(Mat src1, double minarea, double whRatio , int d)
{
    //printf("height_zy is %f",height_zy-0.09);
	for(int j_b=0;j_b<240;j_b++)
    {
    	for (int i_b=0;i_b<320;i_b++)
    	{
    			 	 	 	 	 float ddd_b =float( src1.at<uchar>(j_b,i_b))*2/100;
						if(ddd_b >= (height_zy-0.09)-0.10)
    			 	        		{
									src1.at<uchar>(j_b,i_b) = 0;
    			 	        		}

    	}
    }
	IplImage src2(src1);
	//IplImage* src = cvCreateImage(cvSize(WIDTH,HEIGHT),8,3);
	src_contours=&src2;
    if (!src_contours)
    {
        printf("read data error!\n");
        return -1;
    }
//    IplImage* dst = cvCreateImage(cvGetSize(src_contours), 8, 3);

    cv::Mat raw_dist( src1.size(), CV_8UC1 );
    //cv::Mat deal_dst( src1.size(), CV_8UC1 );

    //Mat dst= Mat::zeros(sizeof(src1), CV_8UC3);
    //the parm. for cvFindContours
    CvMemStorage* storage = cvCreateMemStorage(0);
    CvSeq* contour = 0;

    double maxarea = 0;

    //for display
   // cvNamedWindow("Source", CV_WINDOW_NORMAL);
   // cvShowImage("Source", src);


//    cvNamedWindow("过滤", 3);
//    cvShowImage("过滤", src);
    //二值化
    //二值化

    cvThreshold(src_contours, src_contours, 30, 255, CV_THRESH_BINARY);
//    Dilation(src, 3);
//    Erosion(src,3);
    Erosion(src_contours,1);
    Dilation(src_contours, 1);
    Dilation(src_contours,3);
    Erosion(src_contours,3);
    Dilation(src_contours,5);
    Erosion(src_contours,5);


        //cvNamedWindow("二值化", 3);
       //cvShowImage("二值化", src);
    //提 取轮廓
    cvFindContours(src_contours, storage, &contour, sizeof(CvContour), CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);
   cvZero(dst_contours);//清空数组
   raw_dist = Mat::zeros(src1.size(),  CV_8UC1);
   //deal_dst= Mat::zeros(src1.size(),  CV_8UC1);

   CvSeq* _contour = contour;
   CvSeq* max_contour = 0;
    /*CvSeq* _contour为了保存轮廓的首指针位置，因为随后contour将用来迭代*/



    int maxAreaIdx = -1, iteratorIdx = 0;//n为面积最大轮廓索引，m为迭代索引
    for (int iteratorIdx = 0; contour != 0; contour = contour->h_next, iteratorIdx++/*更新迭代索引*/)
    {

        double tmparea = fabs(cvContourArea(contour));
       // printf("area is %f\n",tmparea);
        if (tmparea > maxarea)
        {
            maxarea = tmparea;
            maxAreaIdx = iteratorIdx;
            continue;
        }
        if (tmparea < minarea)
        {
            //删除面积小于设定值的轮廓
            cvSeqRemove(contour, 0);
            continue;
        }
        CvRect aRect = cvBoundingRect(contour, 0);
                if ((aRect.width / aRect.height)<whRatio)
                {
                    //删除宽高比例小于设定值的轮廓
                    cvSeqRemove(contour, 0);
                    continue;
                }
    }

    contour = _contour;
    int count = 0;
    int valid_count = -1;
    //printf("valid_count = -1!\n");
    float point_x;
    float point_y;
    float point_z;
    float  camera_point_image[3];
    float depth_point_image[3];
    	chess_R_ca = (CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/Rotationr0.xml");
    	body_R_chess=(CvMat*)cvLoad("/home/hitcsc/catkin_ws/src/dji_guidance_sdk/src/under_body_R_chess.xml");
 //cvTranspose(body_R_chess,body_R_chess);
	//cvTranspose(chess_R_ca,chess_R_ca);
	Quaternion_To_Euler(q_guidance, att);

	float roll,pitch,yaw;

	roll = cvmGet(att,0,0);
	pitch = cvmGet(att,1,0);
	yaw = cvmGet(att,2,0);

	/*	R_g_b coming from aerial pilot indicates transformation from ground to body (All observe left-multiply principle)	*/
	Euler_To_Matrix(roll,pitch,yaw,earth_R_body);
    		cvGEMM(saidong_R_earth,earth_R_body,1,NULL,0,saidong_R_body);
            cvGEMM(saidong_R_body,body_R_chess,1,NULL,0,saidong_R_chess);
           	cvGEMM(saidong_R_chess,chess_R_ca,1,NULL,0,saidong_R_ca);
 //          printf("\n%f	%f	%f \n %f	%f	%f \n%f	%f	%f\n",cvmGet(saidong_R_body,0,0),cvmGet(saidong_R_body,0,1),cvmGet(saidong_R_body,0,2),cvmGet(saidong_R_body,1,0),cvmGet(saidong_R_body,1,1),cvmGet(saidong_R_body,1,2),cvmGet(saidong_R_body,2,0),cvmGet(saidong_R_body,2,1),cvmGet(saidong_R_body,2,2));
//			cout << "---earth_R_body---" << endl;
//			for(int i = 0;i < 9;i++){
//				cout << earth_R_body->data.fl[i] << ' ';
//				if(!((i+1)%3))
//					cout << endl;
//			}
        for (; contour != 0; contour = contour->h_next)
        {
        	//raw_dist = Mat::zeros(src1.size(),  CV_8UC1);
            int point_sum_x = 0;
            int point_sum_y = 0;
            int point_average_x = 0;
            float point_average_z = 0;
            int point_average_y = 0;
            int point_count = 0;
        	count++;
            double tmparea = fabs(cvContourArea(contour));
            //if (tmparea == maxarea /*k==n*/)
            if (tmparea > 750)
            {
                CvScalar color = CV_RGB(255, 255, 255);
                cvDrawContours(dst_contours, contour, color, color, -1, CV_FILLED, 8);
               // max_contour = contour;
                for(int j=0;j<dst_contours->height;j++)
                {
                	for (int i=0;i<dst_contours->width;i++)
                	{
                		 if(cvPointPolygonTest( contour,cvPoint2D32f(i,j), 0 )>0)
                		                  {
                			 	 	 	 	 float ddd =float( src_src.at<uchar>(j,i))*2/100;
                			 	 	 	 	 if(ddd>0.3&&ddd<3.0)
                			 	 	 	 	 {
                			 	 	 	 		 point_z =  ddd;
                 			 	 	 	 	    point_x = (i - camera_cu) * point_z / focal;
                			 	 	 	 	     point_y = (j - camera_cv) * point_z / focal;
                			 	 	 	 	     point_sum_x = point_sum_x + i;
                			 	 	 	 	     point_sum_y = point_sum_y + j;
                			 	 	 	     	 point_count = point_count + 1;
                			 	 	 	  	    //printf("point_y is %d\n", point_sum_x);
                			 	 	 	     	raw_dist.at<uchar>(j,i) = 	src_src.at<uchar>(j,i);
                			 	 	 	 	     camera_point_image[0] = point_x;
                			 	 	 	 	     camera_point_image[1] =point_y;
                			 	 	 	 	     camera_point_image[2] = point_z;
//                			 	 	 	 	    if(point_z>height_zy-0.15)
//                			 	 	 	 	    {
//                			 	 	 	 	    	raw_dist.at<uchar>(j,i) = 0;
//                			 	 	 	 	    }
                			 	          		transform_point_to_real(depth_point_image, saidong_R_ca, camera_point_image);
                			 	          		//if(depth_point_image[2] >= height_zy-0.2)//去除地面点
									if(depth_point_image[2] >= (height_zy-0.09)-0.10)
                			 	        		{
                			 	        			raw_dist.at<uchar>(j,i) = 0;
                   			 	 	 	     	    point_count = point_count - 1;
                   			 	 	 	     	    point_sum_x = point_sum_x - i;
                   			 	 	 	     	    point_sum_y = point_sum_y - j;
                			 	        		}
                			 	 	 	 	 }

            			 	 	 	 	    //imshow("bufen分开2", raw_dist);
                		                  }
                	}
                }
                if(point_count>=30)
                {
                	valid_count++;
                	//printf("point_count is %d\n", point_count);
                	point_average_z = float(grey(raw_dist))*2/100;
                	 point_average_x = cvRound(point_sum_x / point_count);
                	 point_average_y = cvRound(point_sum_y / point_count);
                	 cv::circle(raw_dist, Point(point_average_x,point_average_y), 5, Scalar(255,0,0),  -1, 8, 0);
                   // printf("point_average_x is %d***point_average_y is %d\n", point_average_x,point_average_y);
                	 point_x = (point_average_x - camera_cu) * point_average_z / focal;
                	 pub_point_x = point_x;
                	 pub_point_y =  (point_average_y - camera_cv) * point_average_z / focal;
                	 pub_point_z = point_average_z;
                   //printf("point_x is %f***point_y is %f***point_z is %f***valid_count is %d\n", pub_point_x,pub_point_y,pub_point_z,valid_count);
                	 if(valid_count==0)
                	 {
                		 if(sqrt(pub_point_x*pub_point_x+pub_point_z*pub_point_z)<height_zy-0.09)
                		 {
                			 obstacle_delect_x[valid_count] = pub_point_x;
                			 obstacle_delect_y[valid_count] = pub_point_y;
                			 obstacle_delect_z[valid_count] = pub_point_z;
                			 pub_obstacle_under_count = pub_obstacle_under_count+1;
                			  	//printf("point_y is %f\n", pub_point_z);
                			// printf("*********%f***********\n",atan2(obstacle_delect_x[valid_count],obstacle_delect_y[valid_count])*180/PAI );
                			// printf("area is %f*******obstacle(%d)\n",tmparea,valid_count+1);
                		 }
                		 else
                		 {
                			 valid_count=valid_count-1;
                            // printf("valid_count -1!\n");
                		 }
                	 }
                	 if(valid_count>0)
                	 {
                		 if(abs(atan2(pub_point_z,pub_point_x)*180/PAI-atan2(obstacle_delect_z[valid_count-1],obstacle_delect_x[valid_count-1])*180/PAI)>5)
                		 {
                			 if(sqrt(pub_point_x*pub_point_x+pub_point_z*pub_point_z)<height_zy-0.09)
                			 {
                				 obstacle_delect_x[valid_count] = pub_point_x;
                				 obstacle_delect_y[valid_count] = pub_point_y;
                				 obstacle_delect_z[valid_count] = pub_point_z;
                				 pub_obstacle_under_count = pub_obstacle_under_count+1;
                				// printf("%f***********************%f\n",atan2(obstacle_delect_x[valid_count],obstacle_delect_y[valid_count])*180/PAI , atan2(obstacle_delect_x[valid_count-1],obstacle_delect_y[valid_count-1])*180/PAI);
                			//	 printf("area is %f*******obstacle(%d)\n",tmparea,valid_count+1);
                			 }
                			 else
                			 {
                    			 valid_count=valid_count-1;
                                // printf("valid_count -1!\n");
                			 }
                		  }
                		 else
                		 {
                			 if(sqrt(pub_point_x*pub_point_x+pub_point_z*pub_point_z)<height_zy-0.09)
                			 {
                				 valid_count=valid_count-1;
          			 			 obstacle_delect_x[valid_count] = pub_point_x;
                				 obstacle_delect_y[valid_count] = pub_point_y;
                				 obstacle_delect_z[valid_count] = pub_point_z;
                			 }
                			 else
                			 {
                    			 valid_count=valid_count-1;
                                 //printf("valid_count -1!\n");
                			 }
                		 }
                	 }
                }
          	   //  printf("pub_obstacle_count is %d\n", pub_obstacle_count);
            }
            /*k++;*/
        }
        //printf("The total number of contours is:%d", count);
	    cvShowImage("轮廓0", dst_contours);
    	imshow("分开0", raw_dist);
    for(int iii = 0 ; iii < valid_count+1;iii++)
    {
        camera_point_real_word[0] = obstacle_delect_x[iii];
        camera_point_real_word[1] = obstacle_delect_y[iii];
        camera_point_real_word[2] = obstacle_delect_z[iii];
        //printf("carema*********************%f,%f,%f********************\n",camera_point_real_word[0], camera_point_real_word[1],camera_point_real_word[2]);
          		transform_point_to_real(depth_point_real_word, saidong_R_ca, camera_point_real_word);
          		pub_obstacle_yqt_under_x[iii] = depth_point_real_word[0];
          		pub_obstacle_yqt_under_y[iii] = depth_point_real_word[1];
        		printf("*obstacle[%d] in camera[%d] in camera frame is(%f,%f,%f)\n",iii+1,d,camera_point_real_word[0],camera_point_real_word[1],  camera_point_real_word[2]);
        		printf("*the distance of obstacle[%d] in camera[%d] in camera frame is [%f]\n",iii+1,d,sqrt(camera_point_real_word[0]*camera_point_real_word[0]+camera_point_real_word[2]*camera_point_real_word[2]));
        		printf("*obstacle[%d] in camera[%d] in saidong frame is(%f,%f,%f)\n",iii+1,d,depth_point_real_word[0],depth_point_real_word[1],  depth_point_real_word[2]);
        		printf("-+-+-+-\n");

        }
   //stat_obstacle_count_under = pub_obstacle_under_count;

}
void dealwithit(int d , Mat src)
{
	//IplImage* pImg = cvCreateImage(cvSize(WIDTH,HEIGHT),8,1);;
	//namedWindow("src frame");
	src.copyTo(src_src);
//	IplImage qImg(src);
	if(d==0)
	{
		getContoursByC_under(src,30.0,5.0 , d);
	}
	else
	{
		getContoursByC(src,30.0,5.0 , d);
	}
	//imshow("src frame",src_src);
//	   if(d == 0)
//	    {
//			cvShowImage("Extracted frame_0",&qImg);
//
//	    }
//	    if(d == 1)
//	    {
//	    	cvShowImage("Extracted frame_1",&qImg);
//
//	    }
//	    if(d == 2)
//	    {
//	    	cvShowImage("Extracted frame_2",&qImg);
//
//	    }
//	    if(d == 3)
//	    {
//	    	cvShowImage("Extracted frame_3",&qImg);
//
//	    }
//	    if(d == 4)
//	    {
//
//	    	cvShowImage("Extracted frame_4",&qImg);
//
//	    }
//    iarc007::obstacle obstacle_depth_pub;
//    obstacle_depth_pub.header.frame_id = "guidance_obstacle";
//    obstacle_depth_pub.header.stamp    = ros::Time::now();
//    //obstacle_depth_pub.num=20;
//    obstacle_depth_pub.obstacle_x.resize(20);
//    obstacle_depth_pub.obstacle_y.resize(20);
//    for(int i=0;i<1;++i)
//    {
//  	  obstacle_depth_pub.obstacle_x[i]=pub_point_x;
//  	  obstacle_depth_pub.obstacle_y[i]=pub_point_y;
//    }
//    obstacle_guidance_pub[d].publish(obstacle_depth_pub);
	//cvReleaseImage(&pImg);
}
/* depth greyscale image */

int main(int argc, char** argv)
{
   
  
    CvMat *Rotation_guidance=cvCreateMat(3,3,CV_32FC1);
   //CvMat *P0=cvCreateMat(3,1,CV_32FC1);
 //   CvMat *P=cvCreateMat(3,1,CV_32FC1);
    
    ros::init(argc, argv, "GuidanceNodeTest");
    ros::NodeHandle my_node;
    ros::Publisher obstacle_pub = my_node.advertise<iarc007::obstacle>("yqt_obstacle",10);
    ros::Publisher obstacle_pub_under = my_node.advertise<iarc007::obstacle>("yqt_obstacle_under",10);
    iarc007::obstacle obstacle_depth_pub;
    iarc007::obstacle obstacle_depth_under_pub;
    obstacle_depth_pub.obstacle_x.resize(20);
    obstacle_depth_pub.obstacle_y.resize(20);
    obstacle_depth_pub.biaozhiwei.resize(20);
    obstacle_depth_under_pub.obstacle_x.resize(20);
	obstacle_depth_under_pub.obstacle_y.resize(20);
	obstacle_depth_under_pub.biaozhiwei.resize(20);
    iarc007::obstacle obstacle_depth_pub_under;
    obstacle_depth_pub_under.obstacle_x.resize(20);
    obstacle_depth_pub_under.obstacle_y.resize(20);
    obstacle_depth_pub_under.biaozhiwei.resize(20);
//    left_image_sub        = my_node.subscribe("/guidance/left_image",  10, left_image_callback);
    right_image_sub       = my_node.subscribe("/guidance/right_image", 20, right_image_callback);
      //depth_image_sub       = my_node.subscribe("/guidance/depth_image_1", 10, depth_image_callback);
    depth_image_sub      = my_node.subscribe("/guidance/depth_image", 20, depth_image_callback);


     left_image_sub = my_node.subscribe("/guidance/left_image",10 , left_image_callback);

     imu_sub               = my_node.subscribe("/guidance/imu", 1, imu_callback);
     velocity_sub          = my_node.subscribe("/guidance/velocity", 1, velocity_callback);
     obstacle_distance_sub = my_node.subscribe("/guidance/obstacle_distance", 1, obstacle_distance_callback);
  	 ultrasonic_sub = my_node.subscribe("/guidance/ultrasonic", 1, ultrasonic_callback);
  	 position_sub = my_node.subscribe("/guidance/position", 1, position_callback);
  	 float real_distance_yqt_x=0;
  	 float real_distance_yqt_y=0;
  	 int cam_pair = 0;

//  	 for(int i=0;i<5;i++)
//     {
//  		 sprintf(obstacle_guidance_pub_topic[i],"/guidance/obstacle_position_%d",i);
//
//  		 obstacle_guidance_pub[i] = my_node.advertise< iarc007::obstacle >(obstacle_guidance_pub_topic[i],1);
//  	  }
         // Create a ROS publisher for the output point cloud
  	 //***************************************************************************************************start
  	 FILE *jrh_q=fopen("/home/hitcsc/catkin_ws/src/iarc007/src/JRH_pilot/data/Q_INIT.txt","r");
  	      if(!jrh_q)
  	      {
  	          std::cout << "File open failed !" << std::endl;
  	//                    return 0;
  	      }
  	//      double time;

  	      float q0,q1,q2,q3;
  	      CvMat *q_init_zy=cvCreateMat(4,1,CV_32FC1);
  	      CvMat *att_init_zy=cvCreateMat(3,1,CV_32FC1);
  		q_att_zy=cvCreateMat(4,1,CV_32FC1);
  	      att_zy=cvCreateMat(3,1,CV_32FC1);
  	      earth_R_saidong=cvCreateMat(3,3,CV_32FC1);
  	      saidong_R_earth=cvCreateMat(3,3,CV_32FC1);
  	      chess_R_ca=cvCreateMat(3,3,CV_32FC1);
  	      body_R_chess=cvCreateMat(3,3,CV_32FC1);
  	      saidong_R_chess=cvCreateMat(3,3,CV_32FC1);
  	       saidong_R_ca=cvCreateMat(3,3,CV_32FC1);
  	       saidong_R_body=cvCreateMat(3,3,CV_32FC1);
  	       earth_R_body=cvCreateMat(3,3,CV_32FC1);
		att = cvCreateMat(3,3,CV_32FC1);
  	     cvmSet(intr, 0, 0, focal);
  	     cvmSet(intr, 0, 1, 0.0);
  	     cvmSet(intr, 0, 2, camera_cu);
  	     cvmSet(intr, 1, 0, 0.0);
  	     cvmSet(intr, 1, 1, focal);
  	     cvmSet(intr, 1,2, camera_cu);
  	     cvmSet(intr, 2, 0, 0.0);
  	     cvmSet(intr, 2, 1, 0.0);
  	     cvmSet(intr, 2, 2, 1.0);


  	      fscanf(jrh_q,"%f%f%f%f\n",&q0,&q1,&q2,&q3);
  	      fclose(jrh_q);

  	          cvmSet(q_init_zy, 0, 0, q0);
  	      cvmSet(q_init_zy, 1, 0, q1);
  	      cvmSet(q_init_zy, 2, 0, q2);
  	      cvmSet(q_init_zy, 3, 0, q3);

  	      Quaternion_To_Euler(q_init_zy,att_init_zy);
  	      Euler_To_Matrix(cvmGet(att_init_zy,0,0),cvmGet(att_init_zy,1,0),cvmGet(att_init_zy,2,0),earth_R_saidong);
	      cvTranspose(earth_R_saidong,saidong_R_earth);

  	      ultrasonic_sub = my_node.subscribe("/guidance/ultrasonic", 1, ultrasonic_callback);
  	      attitude_quaternion_subscriber = my_node.subscribe<dji_sdk::AttitudeQuaternion>("/dji_sdk/attitude_quaternion", 1, attitude_quaternion_subscriber_callback);
  	      //**************************************************************************************************************************************end

 ros::Rate r(4);
    while (ros::ok())
    {
       // printf("frame***************************************************");
    	ros::spinOnce();
        pub_obstacle_count = 0 ;

        //printf("%d",vbus_num);

//    	vbus_num++;
//    	if(vbus_num>4)
//    	{
//    		vbus_num = 1;
//    	}
        	{
//        	cam_pair++;
//        	printf("%d",cam_pair);
//			if(cam_pair>=2)
//			{
//				cam_pair = 0;
//			}
//        		        if(vbus_num==0)
//        		        {
//        						printf("*************************************************\n");
//        						cv::Mat color_image_0 = leftMatShow1_0.clone();
//        						if(jiaozheng==false)
//        						{
//        							if (color_image_0.data)
//        								{cout<<"asdfghassdhkasddgasd"<<endl;
//        								jiaozheng=calibration(color_image_0,intr,0);
//        								}
//        						}
////        	        		cv::Mat color_image_0 = leftMatShow1_0.clone();
////        	        	     jiaozheng=calibration(color_image_0,intr,0);
//        		         }
//        		             if(vbus_num==1)
//        		                       {
//        									printf("*************************************************\n");
//        					        		cv::Mat color_image_1= leftMatShow1_1.clone();
//        					        		if(jiaozheng==false)
//        					        			{
//        					        				if (color_image_1.data)
//        					        				{//cout<<"asdfghassdhkasddgasd"<<endl;
//        					        				jiaozheng=calibration(color_image_1,intr,1);
//        					        				}
//        					        			}
////        		            	 	 	 cv::Mat color_image_1 = leftMatShow1_1.clone();
////        		            	        jiaozheng=calibration(color_image_1,intr,1);
//        		                       }
//       		                     if(vbus_num==2)
//        		                          {
//        					        			//printf("*************************************************\n");
//        					        	        cv::Mat color_image_2 = leftMatShow1_2.clone();
//        					        	        if(jiaozheng==false)
//        					        	        {
//        					        	        	if (color_image_2.data)
//        					        	        	{//cout<<"asdfghassdhkasddgasd"<<endl;
//        					        	        	jiaozheng=calibration(color_image_2,intr,2);
//        					        	        	}
//        					        	        }
////        		                    	 	 cv::Mat color_image_2 = leftMatShow1_2.clone();
////        		                    	     jiaozheng=calibration(color_image_2,intr,2);
//        		                          }
//        		                     if(vbus_num==3)
//        		                          {
//        		                    	 	 printf("*************************************************\n");
//        		                    	 	 cv::Mat color_image_3 = leftMatShow1_3.clone();
//											 if(jiaozheng==false)
//											 {
//												 if (color_image_3.data)
//													 {//cout<<"asdfghassdhkasddgasd"<<endl;
//
//												 jiaozheng=calibration(color_image_3,intr,3);
//													 }
//											 }
//        		                          }
        		                     if(vbus_num==4)
        		                          {
        		                    	  	  //printf("*************************************************\n");
        		                    	      cv::Mat color_image_4 = leftMatShow1_4.clone();
        		                    	      if(jiaozheng==false)
        		                    	      {
        		                    	    	  if (color_image_4.data)
        		                    	          {cout<<"asdfghassdhkasddgasd"<<endl;
        		                    	          jiaozheng=calibration(color_image_4,intr,4);
        		                    	      	}
        		                    	      }
//        		                    	 	 cv::Mat color_image_4 = leftMatShow1_4.clone();
//        		                    	      jiaozheng=calibration(color_image_4,intr,4);

        		                          }
//        		cv::Mat color_image;
//        	     jiaozheng=calibration(color_image_,intrinsic,num);
        	}
        	// dealwithit(0,depthMatShow1_0);
        //	if( 0.2+(height_zy-0.09)>0.5)
        	{
           	 dealwithit(1,depthMatShow1_1);
           	 dealwithit(2,depthMatShow1_2);
           	 dealwithit(3,depthMatShow1_3);
           	 dealwithit(4,depthMatShow1_4);
        	}
//        	 dealwithit(1,depthMatShow1_1);
//        	 dealwithit(2,depthMatShow1_2);
//        	 dealwithit(3,depthMatShow1_3);
//        	 dealwithit(4,depthMatShow1_4);
//             for ( int dd = 0; dd < 5; ++dd )
//             {
//                 if(dd == 0)
//                 {
//        	 	 	 dealwithit(0,depthMatShow1_0);
//                 }
//                 if(dd == 1)
//                 {
//        	 	 	 dealwithit(1,depthMatShow1_1);
//                 }
//                 if(dd == 2)
//                 {
//        	 	 	 dealwithit(dd,depthMatShow1_2);
//                 }
//                 if(dd == 3)
//                 {
//        	 	 	 dealwithit(dd,depthMatShow1_3);
//                 }
//                 if(dd == 4)
//                 {
//        	 	 	 dealwithit(dd,depthMatShow1_4);
//                 }
//            }
        	 if(pub_obstacle_under_count ==0)
        	 {
        		 obstacle_depth_under_pub.biaozhiwei[0]=0;
        	 }
        	 if(pub_obstacle_under_count !=0)
        	 {
        		 obstacle_depth_under_pub.biaozhiwei[0]=1;
        	 }
                     if(pub_obstacle_count ==0)
                     {
                		 obstacle_depth_pub.biaozhiwei[0]=0;
                		 obstacle_depth_pub.num=(char)(0);

                     }
                     if((pub_obstacle_count <=  4)&&(pub_obstacle_count>0))
                     {
                    	 for(int iiii = 0;iiii <pub_obstacle_count;iiii++)
                    	 {
                    		 obstacle_depth_pub.obstacle_x[iiii] =  pub_obstacle_yqt_x[iiii];
                    		 obstacle_depth_pub.obstacle_y[iiii] =  pub_obstacle_yqt_y[iiii];
//                    		 printf("the obstacle[%d] longth:%f\t",iiii+1,sqrt(pub_obstacle_yqt_x[iiii]*pub_obstacle_yqt_x[iiii]+pub_obstacle_yqt_y[iiii]*pub_obstacle_yqt_y[iiii]));
 //                   		 printf(" angle:%f\n",atan2( pub_obstacle_yqt_y[iiii], pub_obstacle_yqt_x[iiii]));
                    		 obstacle_depth_pub.num=(char)(pub_obstacle_count);
                    		 obstacle_depth_pub.header.stamp=ros::Time::now();
                    		 obstacle_depth_pub.biaozhiwei[0]=1;
                    	 }
                     }
                     if(pub_obstacle_count >  4)
                     {
                    	 for(int iiii = 1;iiii <pub_obstacle_count;iiii++)
                    	 {
                    		 if(sqrt(pub_obstacle_yqt_x[iiii]*pub_obstacle_yqt_x[iiii]+pub_obstacle_yqt_y[iiii]*pub_obstacle_yqt_y[iiii])>sqrt(pub_obstacle_yqt_x[iiii-1]*pub_obstacle_yqt_x[iiii-1]+pub_obstacle_yqt_y[iiii-1]*pub_obstacle_yqt_y[iiii-1]))
                    		 {
                    			real_distance_yqt_x = pub_obstacle_yqt_x[iiii-1];
                    			real_distance_yqt_y = pub_obstacle_yqt_y[iiii-1];
                    			pub_obstacle_yqt_x[iiii-1] = pub_obstacle_yqt_x[iiii];
                    			pub_obstacle_yqt_y[iiii-1] = pub_obstacle_yqt_y[iiii];
                    			pub_obstacle_yqt_x[iiii] = real_distance_yqt_x;
                    			pub_obstacle_yqt_y[iiii] = real_distance_yqt_y;
                    		 }
                    	 }
                    	 for(int iiii = 0;iiii <pub_obstacle_count;iiii++)
                    	 {
                    		 obstacle_depth_pub.obstacle_x[iiii] =  pub_obstacle_yqt_x[iiii];
                    		 obstacle_depth_pub.obstacle_y[iiii] =  pub_obstacle_yqt_y[iiii];
//                    		 printf("the obstacle[%d] longth:%f\t",iiii+1,sqrt(pub_obstacle_yqt_x[iiii]*pub_obstacle_yqt_x[iiii]+pub_obstacle_yqt_y[iiii]*pub_obstacle_yqt_y[iiii]));
//                    	     printf(" angle:%f\n",atan2( pub_obstacle_yqt_y[iiii], pub_obstacle_yqt_x[iiii]));
                    		 obstacle_depth_pub.num=(char)(4);
                    		 obstacle_depth_pub.header.stamp=ros::Time::now();
                    		 obstacle_depth_pub.biaozhiwei[0]=1;
                    	 }
                     }
//                     printf("*********************\n");
//                     printf("biaozhiwei is %d\n",obstacle_depth_pub.biaozhiwei[0]);
//                     printf("num is %d\n",obstacle_depth_pub.num);
//                     //printf("biaozhiwei is %d\n",obstacle_depth_pub.biaozhiwei[0]);
//                     printf("*********************\n");


                     obstacle_pub.publish(obstacle_depth_pub);
                     obstacle_pub_under.publish(obstacle_depth_under_pub);
                     frame_count++;
                    printf("********count[%d]********\n",frame_count);
                     //cvWaitKey(0);
        r.sleep();
     }


         cvReleaseMat(&q_guidance);
         cvReleaseMat(&chess_R_ca);
         cvReleaseMat(&body_R_chess);
         cvReleaseMat(&saidong_R_chess);
         cvReleaseMat(&saidong_R_ca);
         cvReleaseMat(&earth_R_body);
         cvReleaseMat(&saidong_R_earth);
         cvReleaseMat(&earth_R_saidong);
         cvReleaseMat(&q_att_zy);
         cvReleaseMat(&att_zy);
   	  cvReleaseImage(&src_contours);
   	cvReleaseImage(&dst_contours);
    cvReleaseMemStorage(&storage);


	cvReleaseMat(&att);
        // cvReleaseMat(&P0);
          // cvReleaseMat(&P);
	cvReleaseMat(&Rotation_guidance);
    return 0;
}
